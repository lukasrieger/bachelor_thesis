\section{Testing the real-world implementation of HAGRID}
Given that we had successfully developed a working testing framework for our abstract model, we decided to integrate the actual HAGRID server into our testing efforts.
For obvious reasons, testing HAGRID requires a local server instance to be running on the same machine. 

\paragraph{Communicating with HAGRID}
The main effort of integrating HAGRID into our implementation focussed on the relaying and receiving of messages between our Scala frontend and HAGRID.
To this end, we use \emph{Sttp}, which is a simple library that enables us to communicate with the server through REST-full http calls. The transferred data is being encoded as \emph{JSON}, for which we rely on \emph{Circe} as a library.

HAGRID itself defines a specific interface, through which external applications may communicate with the PGP server. This interface, called \emph{Verifying Keyserver (VKS) Interface}, exposes the following endpoints: 
\begin{itemize}
    \item \mintinline{text}{GET}  \mintinline{text}{/vks/v1/by-fingerprint/FINGERPRINT}
    \item \mintinline{text}{GET}  \mintinline{text}{/vks/v1/by-keyid/KEY-ID}
    \item \mintinline{text}{GET}  \mintinline{text}{/vks/v1/by-email/URI-ENCODED EMAIL-ADDRESS}
    \item \mintinline{text}{POST} \mintinline{text}{/vks/v1/upload}
    \item \mintinline{text}{POST} \mintinline{text}{/vks/v1/request-verify}
\end{itemize}

The interface which actually communicates with the server exposes exactly the same methods as our model, due to it implementing the same 
\mintinline{scala}{HagridInterface}.

Instead of keeping track of keys and identities in the frontend, our \mintinline{scala}{HagridServer} simply relays all actions to HAGRID by http.
As an example, lets look at the \mintinline{scala}{upload} method once again: 
\begin{minted}{scala}
    override def upload(key: Key): Token = {
        val response = basicRequest
            .post(hag("/vks/v1/upload"))
            .body(UploadBody(key.armored))
            .response(asJson[UploadResponse])
            .send()
            .body
 
        Token(response
        .toOption
        .get
        .token)
  }
\end{minted}
First, we construct a simple \emph{POST}-Request which targets the \emph{VKS} endpoint responsible for uploading PGP keys. We then attach the \emph{armored} key-text as the request body and finally instruct the request to encode any eventual response as an instance of \mintinline{scala}{UploadResponse}.
The most crucial bit of information included in the \mintinline{scala}{UploadResponse} is the token, which we require in order to send any verification requests at a later point.

However, it must be noted that our implementation, while fully working, generally \emph{ignores} the possibility of an error occurring while communicating with HAGRID. We are aware that this may cause unforeseen problems in the future.

\subsection{Receiving verification mails from HAGRID}
While we were able to simulate the transmission of verification mails in an abstract and direct way for our server model, we had no such option when dealing with the real-world HAGRID server. 

During the  earlier development phases, we assumed that we would be forced to provide a dummy implementation of \mintinline{bash}{sendmail}, as the documentation claimed that HAGRID would require a working \mintinline{bash}{sendmail} command to be available in the environment in order to send and receive mails.
Luckily, we discovered that HAGRID also provides an alternative mode of operation, in which all email transfer is handled directly through the filesystem.
Modifying the configuration file \mintinline{text}{Rocket.toml} and adding the line \mintinline{text}{mail_folder=/PATH/TO/MAIL}, causes HAGRID to write all mails to a unique file in the specified folder.

This allows us to simply observe the given directory and react to any file modifications within the folder.
More specifically, we defined a method, that would block its execution until it successfully read all expected mails: 
\label{code:consumeMail}
\begin{minted}{scala}
    private def consumeMail(expectedSize: Int): Seq[Body] = {
        val watchKey = mailWatcher.take
        val events = watchKey.pollEvents.asScala
        val updatePaths = events
            .take(expectedSize)
            .map(_.asInstanceOf[WatchEvent[Path]])
            .map(_.context())

        val mails = updatePaths.flatMap { currentPath =>
            val resolved = mailPath.resolve(currentPath).toFile
            val source = Source.fromFile(resolved)
            val bodies: Seq[Body] = parseMail(source.mkString)
            source.close
            resolved.delete
            val isValid = watchKey.reset
            bodies
        }
        mails
  }
\end{minted}
where the returned sequence of mail bodies takes the form of:
\begin{minted}{scala}
    case class Body(fingerprint: Fingerprint, token: Token, identity: Identity)
\end{minted}

\paragraph{Parsing plain text confirmation mails}
In order to consume the emails within the selected directory and actually use the information contained within them, we had to parse the plain text content of said mails and extract the relevant information. In both cases of identity confirmation or revocation, these relevant bits of data would be the \mintinline{scala}{Fingerprint}, the \mintinline{scala}{Token} and finally the respective \mintinline{scala}{Identity} in concern.

For example, a typical mail issued by HAGRID (running as a local instance) in repsonse to a confirmation request might look like this: 
\begin{minted}{text}
    To: <ISSUE_EMAIL@ADDRESS> 
    Hi,
   
    Dies ist eine automatische Nachricht von localhost.
    Falls dies unerwartet ist, bitte die Nachricht ignorieren.
   
    OpenPGP Schlüssel: 23B2E0C54487F50AC59134C3A1EC9765D7B25C5A 
   
    Damit der Schlüssel über die Email-Adresse "<ISSUE_EMAIL@ADDRESS>" gefunden werden kann,
    klicke den folgenden Link:
   
    http://localhost:8080/verify/vrTohvV8q552KMvARBE7foqkvGtUrfDl3iiyX9yqeOX 
   
    Weitere Informationen findest du unter http://localhost:8080/about

\end{minted}
\todo{This mail should be in english as well.}

We currently use a regular expression to parse the relevant information from these mails. This functionality is summarized in a method \mintinline{scala}{parseMail}:
\begin{minted}{scala}
    val VERIFY_PATTERN: Regex = 
        "(?s).*To: <(\\S+)>.*OpenPGP key: ||
        (\\S+).*http://localhost:8080/verify/(\\S+).*<!doctype html>.*".r

    def parseMail(mail: String): Seq[Body] =
        decode[HagridMail](mail)
            .map(mail => new String(mail.message))
            .map {
            case REVOKE_PATTERN(identity, fingerprint, token) => 
                Body(FingerprintImpl(fingerprint), Token(token), PgpIdentity(identity))
            case VERIFY_PATTERN(identity, fingerprint, token) => 
                Body(FingerprintImpl(fingerprint), Token(token), PgpIdentity(identity))
            }
            .toSeq
\end{minted}
As seen in the code sample in \ref{code:consumeMail}, this function is responsible for parsing the mails, that \mintinline{scala}{consumeMail} read from the dedicated mail directory.

\subsection{Generating valid PGP keys}
While our testing efforts were mainly focussed on our own abstract model, we were able to use a simplified representation of our \mintinline{scala}{Key} datatype to represent a PGP key. 
\begin{minted}{scala}
    sealed trait Key {
        def armored: String
        def keyId: KeyId
        def fingerprint: Fingerprint
        def identities: Set[Identity]
        def restrictedTo(ids: Set[Identity]): Key
    }
\end{minted} 
For example, \mintinline{scala}{keyId} simply consists of a unique string identifier that does not hold any specific meaning:
\begin{minted}{scala}
    sealed trait KeyId {
        def value: String
    }
    case class KeyIdImpl(id: String) extends KeyId {
        def value: String = id
    }
    object KeyId {
        def random: KeyId = KeyIdImpl(UUID.randomUUID().toString)
    }
\end{minted}
In order to transmit any \mintinline{scala}{Key} values to the actual HAGRID server, we couldn't rely on the existing dummy implementation, as HAGRID would reject any PGP key that is not properly formatted.

In order to solve this problem, we decided to implement a mechanism that is capable of generating valid PGP keys. 
For this purpose, we use \emph{BouncyCastle}, which is a Java library for cryptographic use cases.

The general signature to generate a PGP key is as following: 
\begin{minted}{scala}
    def genPublicKey(identities: Set[Identity]): (PGPPublicKey, String)
\end{minted}
It should be noted though that we currently do not support the generation of keys with arbitrary amounts of identities. This is due to several unsolved problems which we encountered during development. In the end, these hurdles led to the decision that temporarily supporting a maximum amount of only \emph{two} identities is acceptable.
\newpage
\subsection{Technical challenges}
One major challenge that we faced when trying to incorporate the actual HAGRID implementation in our testing approach was the fact that HAGRID maintains internal state across several distinct instances. This is due to HAGRID persisting uploaded keys and their contents within its installation folder. 
In contrast to this, our high level model of HAGRID maintains no state at all between any two separate test runs.

This is problematic, because our testing approach fundamentally relies on a limited amount of \emph{Identities}, that are subsequently used to construct PGP Keys. This would necessarily lead to unexpected results when applying our approach to HAGRID, where there could potentially already be an identity associated to some PGP key, that was uploaded during a previous testing session. 
To elaborate on this problem, let us assume these two separate test runs in pseudo-code:

Assuming that there exists a value \mintinline{scala}{key1 = Key(identity1,identity2)} and a value \mintinline{scala}{key2 = Key(identity3,identity4)}
 where all arguments to the \mintinline{scala}{Key} constructor are instances of \mintinline{scala}{Identity} with an arbitrary email address, we can define the following two test runs: 
\begin{figure}[!h]
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{minted}{scala}
        upload(key1)
        verify(identity1)
        \end{minted}
        \title{listing}{\textbf{Test run 1}}
    \end{minipage}
    \begin{minipage}{0.5\textwidth}
        \centering
        \begin{minted}{scala}
        verify(identity1)
        upload(key2)
        \end{minted}
        \title{listing}{\textbf{Test run 2}}
    \end{minipage}
\end{figure}

Looking \emph{only} at test run 2 we would expect an outcome, in which the server returns no public keys/identities at all. Instead, when we actually execute these two runs in sequential order, we receive a PGP key when querying the server with \mintinline{scala}{identity1}, even though we \emph{never} uploaded it during the second test. 
Any solution to this problem therefore requires us to reset the internal state of HAGRID after having completed a test.
This in turn also imposes an additional non trivial performance penalty on the execution speed of our ScalaCheck test, besides the slowdown caused by having to generate real PGP keys. 
For our current solution to this problem, we decided to compile HAGRID into a static image. This allows us to create a fresh instance of HAGRID at the beginning of each test iteration and shutting it down afterwards, at which point we simply clear the local directory of PGP keys. This ensures that each test run starts on a truly equal playing field.


